# 큐 (2164) 
https://www.acmicpc.net/status?user_id=lingling29&problem_id=2164&from_mine=1 
## 연결리스트로 구현
###  문제를 풀면서 실수 했던 것
1. card 함수부분에서 입력값 N이 1로 들어왓을 때 예외를 처리해주지 못하여서 segment fault 에러가 났다. 
2. queue구현 부분에서 size 체크를 빈 큐에 새롭게 노드가 들어왔을 경우 예외처리를 해주었는데 이때 size 체크를 잘못하여서 백준에 제출할때마다 '틀렸습니다'가 떴다.
## 원형연결리스트로 구현
### 문제를 풀면서 실수했던 것
1. 단일연결리스트로 큐를 구현할 때는 Node형 front와 rear포인터 변수를 만들어서 구현하였는데, 원형연결리스트는 Node형 head포인터 변수만으로 삽입과 삭제 연산을 구현할 수 있었다. 그러나 구현을 하면서 헷갈리는 부분이 있었다. 삽입을 할때 새로운 노드가 아닌 기존 노드가 새로운 노드를 가리키도록 했어야 했는데 이 부분을 빼먹고 작성하지 않아 계속 에러가 났다. 헷갈렸던 부분을 기록해두도록 하겠따
![Alt text](%EC%9D%B4%EB%AF%B8%EC%A7%80/01.jpg)
![Alt text](%EC%9D%B4%EB%AF%B8%EC%A7%80/02.jpg)

근데 head 포인터 변수를 하나만 사용하기 때문에 원형연결리스트가 단일 연결리스트보다 빠를 줄 알았는데
![Alt text](image.png)
막상 구현해보니 그렇지 않았다. 구현과정에서 쓸데없는 코드를 더 작성해줬었나?



## 고찰
### head 포인터 대신 head노드를 사용!
여태껏 링크드리스트로 큐와 스택을 구현할때 LinkedList 클래스의 데이터 필드에 head 포인터나  front/ rear 포인터를 선언하여 구현하였었는데, 리스트를 구현할 때는  포인터 변수가 아니라 노드 객체를 이용하여 시작노드를 표현한다고 한다.
   
 차이점은 리스트가 공백일때 헤드 포인터 방식을 사용하면 head 값이 nullptr이 되는데 헤드노드방식은 헤드노드의 링크필드가 nullptr값이 된다. 따라서 head 노드의 링크필드가 실직적인 헤드 포인터의 역할을 하여서 head 포인터를 사용하는 것에 비해 삽입이나 삭제 연산 등에서 프로그램 코드가 단순화가 된다고한다.. 

리스트 구현을 건너 뛰고 이중연결리스트를 구현을 시도하였는데 front_push를 구현부터 막혔다.  front_push를 할 때 newNode의 after링크는 head의 값을 할당하면 되지만 
  head는 포인터 변수이기 때문에 newNode를 삽입하기 전의 노드 주소를 가르키기만 하는 역할만 하기 때문에 head 자체의 주소가 존재하지 않아 newNode의 링크필드인 befor 링크가 가르킬 곳이 없었다.

그래서 head포인터를 사용하면서 어떻게 구현을 하지 고민하다가 마땅히 방법이 생각나지 않아 해답을 찾기 위해 다시 리스트를 먼저 구현하기로 하였다.   

리스트를 공부하면서 head를 포인터 변수가 아닌 head 노드 객체를 선언하여 사용하면 된다는 것을 알게 되었다. 그래서 likendList클래스의 데이터필드에 head포인터 변수를 선언하는 대신 head node를 개체를 선언하여 사용하면 head의주소를 알 수 있으니 doubleLinkeList를 구현하는데 문제점을 해결할 수 있을 것 같다. 


### node클래스 안에 삽입/ 삭제 구현 - 객체지향프로그래밍
책에서 객체지향 프로그래밍에서 중요한 습관은 작은 클래스에서 할 수 있는 가능한 한 많은 기능을 구현하는 것이라고 하는데 아직은 그 말 뜻이 이해가 잘 안 간다.

노드를 삭제하고 삽입하는 작업은전체 리스트 정보가 없이도 처리할 수 있기 떄문에 Node 클래스 멤버함수로 구현해 주는 것이 좋다고 한다. 

  그렇지 않으면 리스트 클래스에서 노드의 연결과 관련된 복잡한 연산을 위한 코드를 반복적으로 추가해야하고 결과적으로 복잡하고 불안전한 코드가 나온다고 한다. 

  일단 짜봐야 알거 같다..

## 리스트 구현
.... 포인터랑 친해지니 코딩이 어려웡

1. LinkedList()생성자에서 원래는 항상 head의 포인터 변수를 nullptr로 초기화 해주었었는데 이것은 헤드포인터가 아니라 헤드 노드이기 때문에 Node()생성자에서 항상 link를 nullptr로 초기화 해주므로 따로 nullptr로 초기화 해주지 않아도 된다고 한다.